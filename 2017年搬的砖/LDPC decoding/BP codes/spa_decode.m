function spa_decode(c1,r,H)

err=0;
%发送c1(0 => -1 / 1 => +1)接收为r的先验概率
%variable check
%Q0(1,2):第2个v node传给c node的信息(v=0的情况下)=>化成f0(2)
f1 = 1./(1+exp(-2*r/(0.8*0.8)));
f0 = 1-f1;
%f0 = 1/(sqrt(2*pi)*0.8) * exp(-(r+1).^2/(2*0.8*0.8))
%1./(1+exp(-2*r/(0.8*0.8)));% 
%f1 = 1/(sqrt(2*pi)*0.8) * exp(-(r-1).^2/(2*0.8*0.8)) 
%v => c(根据 H 矩阵判断连接与否，无连接则传递为0)初始化先验知识矩阵Q
Q0 = zeros(8,12);
Q1 = zeros(8,12);
v_n=12; c_n=8;
for i=1:c_n
    for j=1:v_n
        if(H(i,j)~= 0)
            Q0(i,j) = f0(j);
            Q1(i,j) = f1(j);
        end
    end
end
disp(Q0);
R0 = zeros(8,12);
R1 = zeros(8,12);

for iteration = 1:30
    %直接计算R复杂度高
    %{
    %根据c node利用初始化的先验知识计算传递给v node以更新v=1/0的概率R
    [R0(1,:),R1(1,:)] = CalcR2([2,4,6,7,8,12],Q0(1,:),Q1(1,:));
    [R0(2,:),R1(2,:)] = CalcR2([1,3,4,9],Q0(2,:),Q1(2,:));
    [R0(3,:),R1(3,:)] = CalcR2([2,5,7,12],Q0(3,:),Q1(3,:));
    [R0(4,:),R1(4,:)] = CalcR2([1,4,10,11],Q0(4,:),Q1(4,:));
    [R0(5,:),R1(5,:)] = CalcR2([3,5,6,10],Q0(5,:),Q1(5,:));
    [R0(6,:),R1(6,:)] = CalcR2([1,3,7,8 11],Q0(6,:),Q1(6,:));
    [R0(7,:),R1(7,:)] = CalcR2([2,6,8,9,10],Q0(7,:),Q1(7,:));
    [R0(8,:),R1(8,:)] = CalcR2([5,9,11,12],Q0(8,:),Q1(8,:));
    %}
    
    %MacKay & Neal简化计算R的算法
    dQ = Q0-Q1;
    dR = zeros(8,12);
    [dR(1,:)]=CalcDR([2,4,6,7,8,12],dQ(1,:));
    [dR(2,:)] = CalcDR([1,3,4,9],dQ(2,:));
    [dR(3,:)] = CalcDR([2,5,7,12],dQ(3,:));
    [dR(4,:)] = CalcDR([1,4,10,11],dQ(4,:));
    [dR(5,:)] = CalcDR([3,5,6,10],dQ(5,:));
    [dR(6,:)] = CalcDR([1,3,7,8 11],dQ(6,:));
    [dR(7,:)] = CalcDR([2,6,8,9,10],dQ(7,:));
    [dR(8,:)] = CalcDR([5,9,11,12],dQ(8,:));
    
    %计算 R0,R1
    R0 = 1/2*(1+dR).*H;
    R1 = 1/2*(1-dR).*H;
 %{   
    %原来的判决计算方法 
    d = zeros(1,12);
    d(1) = CalcD([2,4,6],f0(1),f1(1),R0(:,1),R1(:,1));
    d(2) = CalcD([1,3,7],f0(2),f1(2),R0(:,2),R1(:,2));
    d(3) = CalcD([2,5,6],f0(3),f1(3),R0(:,3),R1(:,3));
    d(4) = CalcD([1,2,4],f0(4),f1(4),R0(:,4),R1(:,4));
    d(5) = CalcD([3,5,8],f0(5),f1(5),R0(:,5),R1(:,5));
    d(6) = CalcD([1,5,7],f0(6),f1(6),R0(:,6),R1(:,6));
    d(7) = CalcD([1,3,6],f0(7),f1(7),R0(:,7),R1(:,7));
    d(8) = CalcD([1,6,7],f0(8),f1(8),R0(:,8),R1(:,8));
    d(9) = CalcD([2,7,8],f0(9),f1(9),R0(:,9),R1(:,9));
    d(10) = CalcD([4 5 7],f0(10),f1(10),R0(:,10),R1(:,10));
    d(11) = CalcD([4,6,8],f0(11),f1(11),R0(:,11),R1(:,11));
    d(12) = CalcD([1,3,8],f0(12),f1(12),R0(:,12),R1(:,12));
    %}
    
    %判决 d 快速实现方法
    d0 = f0.*prod((R0+1-H));
    d1 = f1.*prod((R1+1-H));
    d = sign(d1-d0);
    
    %校验判断伴随式
    decd=(d+1)./2;
    %计算d*H',验证判决得到的d是否是一个码字，如果是则可以结束迭代
    ps=rem(decd*H',2);
    fprintf('Iteration %d, BER: %d\n',iteration,sum(abs(d-c1))/2);
    %disp(c1);
    disp(d);
    disp(ps);
    if(ps==zeros(1,8))
        break;
    end
    
    
    
    
    %更新 Q0 Q1
    [Q0(:,1),Q1(:,1)] = CalcQ2([2,4,6],f0(1),f1(1),R0(:,1),R1(:,1));
    [Q0(:,2),Q1(:,2)] = CalcQ2([1,3,7],f0(2),f1(2),R0(:,2),R1(:,2));
    [Q0(:,3),Q1(:,3)] = CalcQ2([2,5,6],f0(3),f1(3),R0(:,3),R1(:,3));
    [Q0(:,4),Q1(:,4)] = CalcQ2([1,2,4],f0(4),f1(4),R0(:,4),R1(:,4));
    [Q0(:,5),Q1(:,5)] = CalcQ2([3,5,8],f0(5),f1(5),R0(:,5),R1(:,5));
    [Q0(:,6),Q1(:,6)] = CalcQ2([1,5,7],f0(6),f1(6),R0(:,6),R1(:,6));
    [Q0(:,7),Q1(:,7)] = CalcQ2([1,3,6],f0(7),f1(7),R0(:,7),R1(:,7));
    [Q0(:,8),Q1(:,8)] = CalcQ2([1,6,7],f0(8),f1(8),R0(:,8),R1(:,8));
    [Q0(:,9),Q1(:,9)] = CalcQ2([2,7,8],f0(9),f1(9),R0(:,9),R1(:,9));
    [Q0(:,10),Q1(:,10)] = CalcQ2([4,5,7],f0(10),f1(10),R0(:,10),R1(:,10));
    [Q0(:,11),Q1(:,11)] = CalcQ2([4,6,8],f0(11),f1(11),R0(:,11),R1(:,11));
    [Q0(:,12),Q1(:,12)] = CalcQ2([1,3,8],f0(12),f1(12),R0(:,12),R1(:,12));
    
    disp(Q0);
    disp(Q1);
end
% if(ps~=zeros(1,8))
%     err=err+1;
%     fprintf('EER: %d\n',err);
% end


